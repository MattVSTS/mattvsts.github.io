---
layout: post
title: 'An unusual scenario for Release Management, part 1: testing SonarQube upgrades'
date: '2017-12-01T10:01:00.001Z'
author: Matteo Emili
tags: 
modified_time: '2017-12-01T10:01:37.253Z'
thumbnail: https://lh3.googleusercontent.com/-VFSoMmFTico/WiEoPIcE9HI/AAAAAAAAEvI/D5k6wnVGNXwiYMkHB8IRminLvdybiY2UgCHMYCw/s72-c/wlEmoticon-smile2?imgmax=800
blogger_id: tag:blogger.com,1999:blog-9050180307874313601.post-3123780480769722719
blogger_orig_url: https://mattvsts.blogspot.com/2017/12/an-unusual-scenario-for-release.html
---

<p>Among the many things I do I manage a SonarQube instance. Not a big deal to be fair with you, but it is a valuable tool and it has its quirks. You need to spend time on it.</p><p>So I thought about automating this process a little bit. It is a bit unusual, but it brings some value, so why not!</p><p>The result is a TFS or VSTS Team Project with a TFVC repository (TFVC is perfect for handling binary files!) and two Release Definitions, one for Test and one for Production. </p><p>The reason why there are two Definitions is because – oddly enough – the Test one came after the Production one (which is easier, you’ll discover why later on). I might revamp the whole thing in the future to have sequential environments, but this is it as of now <img class="wlEmoticon wlEmoticon-smile" style="" alt="Smile" src="https://lh3.googleusercontent.com/-VFSoMmFTico/WiEoPIcE9HI/AAAAAAAAEvI/D5k6wnVGNXwiYMkHB8IRminLvdybiY2UgCHMYCw/wlEmoticon-smile2?imgmax=800"></p><p>In the TFVC repository you are going to find folders for each SonarQube version I deployed on my server, together with the relevant sonar.properties file filled with the values you want, and a scripts folder with some utility scripts. </p><p><a href="https://lh3.googleusercontent.com/--C1r4yfEYbQ/WiEoQtxV9cI/AAAAAAAAEvM/3PYPaftp3cMA9haHY3BITEiGGxhClPhJgCHMYCw/s1600-h/image2"><img width="244" height="226" title="image" style="margin: 0px; display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-CsHYVMgFscQ/WiEoSKsNxOI/AAAAAAAAEvQ/DTBWm7wuE6knM6lZGRziaIqOAkBzXiSXACHMYCw/image_thumb?imgmax=800" border="0"></a></p><p>The reason why I am not automating the configuration file creation (via a find-and-replace operation for example) is because you are explicitly told by SonarSource not to just replace this file with an existing version <a href="https://docs.sonarqube.org/display/SONAR/Upgrading">but to start from scratch</a>. </p><p>While testing your configuration you will need to work on it anyway, so it is a good idea to put it in a repository, and you will get versioning for free as well. Bonus.</p><p>Both my Release Definitions feature a Deployment Group: guess what, it contains my SonarQube server <img class="wlEmoticon wlEmoticon-smile" alt="Smile" src="https://lh3.googleusercontent.com/-VFSoMmFTico/WiEoPIcE9HI/AAAAAAAAEvI/D5k6wnVGNXwiYMkHB8IRminLvdybiY2UgCHMYCw/wlEmoticon-smile2?imgmax=800">I also leveraged on Tags, in case I might want to have completely separate enviromnents, as the Deployment Group phases are marked to run only on machines that sport the right tag for the Release Definition. It isn’t the case for now though.</p><p><a href="https://lh3.googleusercontent.com/-Fbvoc59IBBk/WiEoTDOdrFI/AAAAAAAAEvU/VIfl0FRJuqgcyQVIIHOFBNmD_tOeaa4HgCHMYCw/s1600-h/image8"><img width="504" height="99" title="image" style="display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-lRgNn2h8uTg/WiEoUG_DgRI/AAAAAAAAEvY/5wpBXDarR6IyrkM-IKKt2I5yitHT_prqACHMYCw/image_thumb4?imgmax=800" border="0"></a></p><p>Now it comes the fun part, let’s start with the test upgrades. My process for testing SonarQube is as it follows:</p><ul><li>Restore a backup of the production database</li><li>Get the new SonarQube version on the VM that hosts its services</li><li>Extract the new version, set the right values in the sonar.properties file (like different ports and java switches)</li><li>Check that the upgrade runs successfully</li><li>Verify all the involved plugins</li></ul><p>Like I said I am not going to automatically find and replace values in the sonar.properties file, and the latter steps aren’t really worth scripting, but the first two steps can benefit from an automated process.</p><p>This is what my <strong>testing pipeline </strong>looks like:</p><p><a href="https://lh3.googleusercontent.com/-gEa1ziMAImU/WiEoVG0vKEI/AAAAAAAAEvc/VQTJHuPB3v8un4Tb71OICKrrhNW3EHcoACHMYCw/s1600-h/image12"><img width="504" height="335" title="image" style="display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-ULwjSfjPTDk/WiEoWObeE_I/AAAAAAAAEvg/dHH33mAIjTYroMyQXdDt_0PZ52Zfk8FqgCHMYCw/image_thumb6?imgmax=800" border="0"></a></p><p>Nothing too fancy, but it saves time. </p><p>The cool bit here IMHO is the Azure PowerShell script I am running to restore the database: given the Resource Group, Server, Database and SonarQube version (which is used to form the name) I can check if I already have a testing database – if not it starts restoring a backup copy from ten minutes before.</p><p><a href="https://lh3.googleusercontent.com/-1a-bgqPc6RM/WiEoXBCc4rI/AAAAAAAAEvk/Wka0o_-VmO0kEiWfeUUWSPRP2jIQBxWFwCHMYCw/s1600-h/image17"><img width="504" height="71" title="image" style="display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-iScl3xEAhiI/WiEoX6TeMdI/AAAAAAAAEvo/lNByNBEjCB8DV8R_kMVtodlXNVmWgZfowCHMYCw/image_thumb9?imgmax=800" border="0"></a></p><p>If this <em>prerequisite check</em> fails, I integrated the error handling so it stops the task immediately and marks the release as failed:</p><p><a href="https://lh3.googleusercontent.com/-2cmp17bQo5g/WiEoY_MHsBI/AAAAAAAAEvs/zXZ_70HsJawlzr19MG_S4xF-7vQiDRqlQCHMYCw/s1600-h/image21"><img width="504" height="144" title="image" style="display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-bHlV_qpD-zE/WiEoZ_3AgyI/AAAAAAAAEvw/j8Yc7ghbM60fSnRq_AJ7CVU4NCYVm0h_QCHMYCw/image_thumb11?imgmax=800" border="0"></a></p><p><a href="https://lh3.googleusercontent.com/-czfgBSNWob0/WiEoa4F2zaI/AAAAAAAAEv0/kTin1y427IMsXqW0LBotnApLRcdaTvhxgCHMYCw/s1600-h/image25"><img width="504" height="73" title="image" style="display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-pJYWgjksdl4/WiEobgAQifI/AAAAAAAAEv4/ov7eabSXAs4RpL1zsTxhiDns4D6Z6TjXwCHMYCw/image_thumb13?imgmax=800" border="0"></a></p><p>How? Like this:</p><p><a href="https://lh3.googleusercontent.com/-nS3U3YuMZcE/WiEocvi1F0I/AAAAAAAAEv8/pZ9egVwm598Q6KqjwaBHDtRIl8MCrSOlACHMYCw/s1600-h/image30"><img width="504" height="129" title="image" style="display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-pey2fZvC5jA/WiEodmXkV7I/AAAAAAAAEwA/WWO8qreQQE0iqycaVWRxITxS5RtFoh_SwCHMYCw/image_thumb16?imgmax=800" border="0"></a></p><p>The <strong>Write-Error</strong> statement stops the task execution and raises the error message, the <strong>Write-Host</strong> statement with the specific ##vso line marks the task result as failed and the <strong>exit 1</strong> line terminates the sessions so that whatever is next (the database restore!) is not executed.</p><p>Eventually at the end there is an Agentless phase which is just manual intervention with the required things to do:</p><p><a href="https://lh3.googleusercontent.com/-5_J-ql0bmmQ/WiEoenX58HI/AAAAAAAAEwE/YfXnfbz9rGgcailZqwsntDAd9whtjiUggCHMYCw/s1600-h/image34"><img width="504" height="389" title="image" style="display: inline; background-image: none;" alt="image" src="https://lh3.googleusercontent.com/-CHZnU70FlvY/WiEof0ZYslI/AAAAAAAAEwI/hsoVedqlbX80isY4AXmygAl4-dIAPpY8ACHMYCw/image_thumb18?imgmax=800" border="0"></a></p><p>I will go through the <strong>production pipeline</strong> in the next post, as it is different <img class="wlEmoticon wlEmoticon-smile" alt="Smile" src="https://lh3.googleusercontent.com/-VFSoMmFTico/WiEoPIcE9HI/AAAAAAAAEvI/D5k6wnVGNXwiYMkHB8IRminLvdybiY2UgCHMYCw/wlEmoticon-smile2?imgmax=800"></p>